---
title: 💭최종 프로젝트 면접 준비
author: LeeNaYoung
date:   2024-09-04 21:46:06 +09:00
categories: [study]
tags: [study]
---

# 아키텍처 설명

<a href="https://github.com/LeeNaYoung240/LeeNaYoung240.github.io/assets/107848521/c78d9669-787d-4852-8b0e-1f9e400aa3dd" class="popup img-link"><img src="https://github.com/user-attachments/assets/c78d9669-787d-4852-8b0e-1f9e400aa3dd" alt="1" loading="lazy"></a>

- **Jenkins**
	- 개발자가 코드를 **push**하면, **웹훅(webhook)**을 통해 자동으로 **Jenkins 빌드가 트리거되며**, Jenkins는 **SSH**로 **EC2 서버에 접속**하여 작업을 수행합니다. Jenkins는 빌드 및 배포 상태를 **Slack으로 알림**합니다.
	- **Jenkins가 SSH로 EC2에 접속하여 Docker Hub에서 최신 버전의 이미지를 pull 받습니다.** 기존 버전의 컨테이너는 down 시키고, **새로 pull한 최신 버전의 이미지를 기반으로 컨테이너를 up 시킵니다.** 이를 통해 애플리케이션의 최신 버전이 유지되도록 합니다.

- **Redis, Spirng**

	- Redis와 Spring은 각각 Docker 컨테이너로 구성되어 EC2 인스턴스에 배포되어있습니다.

	- 각각의 컨테이너로 배포한 이유는 EC2 하나가 하나의 가상의 컴퓨터라고 생각하면 됩니다. Spring 애플리케이션과 Redis를 서로 다른 인프라에 배포함으로써, 하나의 서비스가 중단되더라도 다른 서비스에 영향을 주지 않게 됩니다. 예를 들어 Redis가 문제가 생겨도 Spring 애플리케이션 자체는 여전히 작동할 수 있습니다.

	- 여기서 도커로 EC2에 배포한 이유는 Redis를 도커에 컨테이너화하면 Redis를 설치, 관리, 배포하는 작업이 단순화해지고 네트워크에서 빠르고 안정적으로 Redis에 접근할 수 있기 때문입니다.

	- Redis를 이용하여 시간별 조회수를 계산하여 랭킹을 산정합니다. 읽기에 장점이 있는 key-value 형식인 Redis에 저장한 후 사용자가 접근 시에 Redis에서 랭킹 데이터를 꺼내서 조회하도록 적용시켰습니다.

- **RDS, MySQL**

	- RDS는 데이터베이스 서버 관리를 자동화하여 운영 부담을 줄여줍니다. EC2 인스턴스에 DB를 설치하여 데이터를 관리하는 것은 개인 소유 차량을 이용하는 것과 비슷합니다. 개인 소유 차량을 이용하면 유지 보수, 보험처리 같은 일들은 온전히 운전자가 부담합니다. 차량 정비를 위해 정비소에 주기적으로 방문해야 하고 기타 차량과 관련된 다른 일이 생길 때 들여야하는 시간과 수고가 큽니다. 즉, 사용자가 일일이 시간을 투자하여 데이터베이스 엔진의 설치와 버전관리, 데이터 백업 등을 해야된다는 단점이 있습니다.

	- 하지만 RDS를 사용하면 렌터카 회사에서 차량을 대여하는 것과 비슷합니다. 렌터카 회사에서 차량을 대여하면 대여 차량과 관련하여 시간이 들어가는 일들을 렌터카 회사에서 대신 처리하고 운전자는 차량을 관리하는 일에 대해서 시간을 따로 쏟을 필요 없이 운전만 하면 되기 때문에 매우 편리합니다.
	
	- RDS를 이용하면 데이터베이스 유지 보수와 관련된 일들을 RDS에서 전적으로 자동 관리하기 때문에 사용자가 해야 할 일은 초기 설정을 제외하고 데이터베이스에 저장된 데이터를 관리하는 일밖에 없기에 큰 편의성을 느낄 수 있습니다.

- **MySQL**

	- MySQL은 높은 성능을 가진 빠른 읽기 작업을 지원하며, 상대적으로 간단한 읽기 작업을 수행할 때 효과적으로 읽기 중심의 작업에 유용하며, 데이터 업데이트가 자주 이루어지지 않는, 프로토타입 또는 작은 규모의 애플리케이션에 적합합니다.

	⇒ 우리 프로젝트는 쓰기 작업이 빈번하기 보다는 읽기 작업이 훨씬 많을 것으로 보이고 규모도 그렇게 크지 않다고 판단해서 mysql을 선택했습니다.

- **EC2**

	- EC2를 선택한 이유는 ECS를 사용한다면 Docker 기반의 컨테이너 방식으로 배포를 해주고 EC2를 Fargate와 함께할 경우 운영을 AWS에게 맡길 수 있는 Serverless 엔진이기 때문에 편리하다는 장점이 있지만 배포를 처음 해보는 것이고 과정 하나하나를 직접 진행하며 EC2에 대해 더욱 숙지한 뒤에 ECS를 시도하는 것이 좋을 것이라 판단하여 EC2로만 배포하는 방법을 선택했습니다.

- **S3**

	- 사용자가 대표 사진이나 마커에 글, 사진을 등록할 때 이미지를 업로드 해야되므로 파일 업로드를 할 수 있는 S3를 도입했습니다.
	
	- 직접 업로드하면 다른 서버가 존재할 경우 해당 서버에서는 파일을 사용할 수 없고 서버에 부하가 생기게 되며 성능 저하의 우려가 있기 때문에 S3에 따로 저장하기로 의사결정 했습니다.


- **Rout53**

	- 도메인의 이름을 IP 주소로 변환하는 DNS(Domain Name Server) 서비스로 예를 들어, 사용자가 https://detourofficial.com/ 과 같은 도메인 이름을 입력하면 Route53은 이를 192.0.X.X과 같은 IP 주소로 변환하여 사용자가 요청한 웹 서버에 연결되도록 합니다.
	
	- **route 53의 핵심: 도메인 네임 서버를 임대해주는 역할**

	- DNS 서버 관리, Spring떠 있는 EC2에 들어갈 수 있는 방법은 rout53을 통해 도메인 네임으로 들어가기 or IP 주소로 들어가기.
	
	- 저희가 산 도메인 주소와 EC2 IP주소랑 연결 : 호스팅

	- EC2마다 IP 주소가 다 다릅니다.(3개가 다른 것)

	- EC2가 꺼지면 IP 주소가 바뀌기 때문에 탄력적 IP 주소를 통해 고정 IP를 부여해야 EC2를 끄고 키고 해도 IP 주소의 변동이 없습니다.

	- NGINX(웹 서버) 스프링보다 앞 단에 나와있는 서버로 Spring을 좀 더 안정적으로 띄워주는 역할. EC2에 NGINX 설치하고 그 위에 띄우는 게 기본적인데 설계가 잘못됨. 원래는 웹 서버로 배포해야 됨. 웹서버까지는 아니고 왓슨의 역할을 해서 AWS랑 웹서버랑은 다릅니다.

	-   ec2 -> nginx -> spring
	
	-   그래도 돌아가는 이유는 spring에 apache tomcat이 내장되어 있는데 이게 WAS의 역할이기 때문에 (WebServer랑 다릅니다)

- Front
	- React를 사용했고 vercel을 통해 배포했습니다.

	- vercel이 react랑 연결하고 rout53을 통해 호스팅합니다. 